{"categories":[{"title":"NGINX","uri":"https://xianliguang.github.io/categories/nginx/"}],"posts":[{"content":"众所周知微服务架构的一个最大的有优势就是可以快速简单的扩容服务实例，要实现这个功能你需要一个负载均衡器来帮助你在众多的实例中选择一个可用的实例，并且能在可用实例发生变化的时候快速通知负载均衡器，这一系列的动作也被称作服务发现。\nNGINX Plus提供了两种方式来和服务发现功能进行整合：NGINX Plus API 和 Domain Name System (DNS) ，本篇文章主要是介绍后一种。\n当你通过增加（减少）虚拟机或者容器来扩容服务（本文称作后端服务）的时候，负载均衡器的配置也必须同步反映出后端服务每次变动。鉴于扩容随时都有可能发生，我们需要通过DNS来实现自动服务发现。\n很多应用平台(例如Kubernets)都提供了基于DNS的服务发现功能，在文章末尾我们会提供一些链接来介绍如何将NGINX Plus整合进这些平台以及那些通过DNS来实现的服务发现的工具。\nDNS特性 在解释如何通过DNS配置服务发现之前，我们先来看一下DNS一些特性。\nTTL 为了防止DNS客户端使用过期的信息，DNS记录提供了一个叫time‑to‑live（TTL）的字段用来告诉客户端这条记录的有效时长。客户端必须在一条记录过期后重新从DNS服务器更新一次最新信息。NGINX Plus默认就遵守TTL的规定，并且在TTL的基础上提供了更加细粒度的控制，即你可以通过配置让NGINX Plus忽略TTL，然后定期更新DNS信息。我们在后面也会讨论NGINX开源版本是如何处理TTL的。\nDNS over TCP 默认情况下，DNS客户端是通过UDP和服务端进行通信的，但如果一个域名配置被解析为很多后端IP地址的话，DNS服务的回包可能会超过UDP单个报512字节的限制。使用TCP可以解决这个问题，当一个完整的记录大小超过一个数据包的时候，DNS服务会在回包设置一个截断标记，用来告诉客户端使用TCP来获取全部记录信息。TCP获取DNS信息是从NGINX 1.9.11开始支持的，并且NGINX Plus R9开始也开始支持。如果想要了解更多可以参考这里。\nSRV记录 DNS可以将将主机名解析成IP地址，但端口如何解决呢？例如当你需要对一些Docker容器进行负载均衡的时候，你不能依靠一些众所周知的端口，以为所有的端口都是动态分配的。DNS有一个特殊的记录类型，叫做SRV记录，SRV记录会包含端口号和一些参数的。NGINX Plus R9以及以后的版本都支持SRV记录。\n使用DNS为NGINX提供服务发现 接下来我们将根据复杂度依次给大家介绍5中使用DNS为NGINX以及NGINX Plus提供服务发现的方法。前3个同时适用于NGINX和NGINX Plus，最后两个值适用于NGINX Plus。\n假设我们对于DNS Server，它的ip为10.0.0.2，backends.example.com 有三个Ip地址，我们可以通过nslookup这个工具的看一下这个热地址的后端ip。\n$ nslookup backends.example.com 10.0.0.2 Server:\t10.0.0.2 Address:\t10.0.0.2#53 Name:\tbackends.example.com Address: 10.0.0.11 Name:\tbackends.example.com Address: 10.0.0.10 Name:\tbackends.example.com Address: 10.0.0.12  使用NGINX的DNS服务发现功能 我们先介绍三种用可以在NGNIX开源版中使用DNS做服务发现的方法，当然这三种方法也可以用在NGINX Plus上。\n使用proxy_pass 定义一组后端服务最简单的方法就是直接使用proxy_pass中生命一个具体的域名，如下：\nserver { location / { proxy_pass http://backends.example.com:8080; } }  NGINX会在启动的时候去加载配置，并通过查询DNS服务器来解析backends.example.com。DNS服务器会将backends.example.com解析成三个ip，然后NGINX默认使用Round Robin算法来对他们进行负载均衡。NGINX会从操作系统的 /etc/resolv.conf这个文件中的找到要使用的DNS服务。\n这个方法是最不具灵活性的一种服务发现方法，有如下加个缺点：\n 如果域名不能被解析，NGINX会启动失败或者重新加载配置 NGINX会缓存DNS记录一直到下次重启或者重新加载配置，并且会忽略DNS记录的TTL 我们不能使用其他的负载均衡算法，同样我们也不能配置被动健康检查或者其他指令参数  使用upstream 为了充分利用NGINX提供的负载均衡算法，我们可以定义一组upstream服务。和直接使用ip来定义服务不同，这里我们使用域名作为server指令的参数。\n正如前面展示的那样，backends.example.com会在NGINX启动或重新加载配置的时候被解析成三个后端服务。但是现在我们可以使用一个叫做最少连接优先的更复杂的负载均衡算法，同时我们还配置了max_fails来开启被动健康检查，以便让NGINX在三次连续失败的请求后将对应后端服务标记为下线.\nupstream backends { least_conn; server backends.example.com:8080 max_fails=3; } server { location / { proxy_pass http://backends; } }  尽管这种方法可以让我们选择负载均衡算法并且配置健康检查，但它仍然有着和前一个方法一样的缺点：缓存和忽略DNS记录的TTL\n使用变量 这个方法是第一种方法的变种，但是它可以让我们控制NGINX多久解析一次域名，如下：\nresolver 10.0.0.2 valid=10s; server { location / { set $backend_servers backends.example.com; proxy_pass http://$backend_servers:8080; } }  当你在proxy_pass中使用参数声明一个域名的时候，NGINX会TTL失效后重新解析域名。你必须显示的使用resolver声明一个域名服务，你也可以告诉NGINX忽略域名的TTL然后按照一定的频率来解析域名，上面的配置就是告诉NGINX每10秒重新解析一次。\n注意：这种方法对于TCP/UDP的负载均衡是从NGINX 1.11.3和NGINX Plus R10开始支持的。\n这中方法消灭了第一种的两个缺点，但是由于不能使用upstream组，你仍然不能使用其他的负载均衡算法或者其他的server参数配置(第二种方法介绍的)。\n使用NGINX Plus的DNS服务发现功能 接下来我们看下2个NGINX Plus专属的DNS服务发现功能\n使用A记录 在NGINX Plus中，我们可以用我们期望的频率来解析DNS，并且没有前三种方法的缺点。开启方法如下：\n 使用resolver指令来声明域名解析服务 在upstream配置中使用zone指令分配共享内存 在server指令中使用域名的地方增加resolve参数  配置样例如下:\nresolver 10.0.0.2 valid=10s; upstream backends { zone backends 64k; server backends.example.com:8080 resolve; } server { location / { proxy_pass http://backends; } }  默认情况下NGINX Plus会在域名记录超时后重新解析，如果想让NGINX Plus以固定频率解析，我们可以在resolver指令中配置valid参数。\n上面的配置片段，每隔10秒种NGINX Plus都会去域名服务10.0.0.2重新解析backends.example.com。如果在启动或者重新加载配置的时候解析失败，NGINX Plus会给返回502页面。\n使用SRV记录 NGINX Plus R9及后面的版本都支持DNS SRV记录。这使得NGINX Plus不仅可以从域名服务获取IP地址并且可以同时获取端口号,权重以及优先级等配置。这个功能在端口号会经常变更的微服务的环境里是非常有用的。\nSRV记录有三个部分组成：服务名，通信协议，域名。域名服务10.0.0.2配置了3条SRV记录，每条记录都包含服务名http，通信协议tcp，域名backends.example.com，如下：\n$ nslookup -query=SRV _http._tcp.backends.example.com 10.0.0.2 Server:\t10.0.0.2 Address:\t10.0.0.2#53 _http._tcp.backends.example.com\tservice = 0 2 8090 backend-0.example.com. _http._tcp.backends.example.com\tservice = 0 1 8091 backend-1.example.com. _http._tcp.backends.example.com\tservice = 10 1 8092 backend-2.example.com.  通过解析每条SRV记录，可以得到对应的ip地址：\n$ nslookup backend-0.example.com 10.0.0.2 ... Name:\tbackend-0.example.com Address: 10.0.0.10 $ nslookup backend-1.example.com 10.0.0.2 ... Name:\tbackend-1.example.com Address: 10.0.0.11 $ nslookup backend-2.example.com 10.0.0.2 ... Name:\tbackend-2.example.com Address: 10.0.0.12  我们仔细分析一下nslookup返回的SRV记录：\n- _http._tcp.backends.example.com\tservice = 0 2 8090 backend-0.example.com.   _http._tcp – SRV记录服务名以及协议名。我们需要将这些作为参数在server指令中声明。 0 – 优先级。 值越小优先级越高。 NGINX Plus会使用优先级最高的服务作为主服务，其他的作为备服务。 2 – 权重。 NGINX Plus会使用这个值作为后端服务在upstream组中的权重（和server指令中的权重参数一致）。 8090 – 端口号。NGINX Plus使用这个值作为后端服务在upstream组中的端口。 backend‑0.example.com – 后端服务域名。NGINX Plus会解析这个域名然后将解析到的所有后端服务加入到upstream。  下面是如何配置NGINX Plus使用SRV记录的例子：\nresolver 10.0.0.2 valid=10s; upstream backends { zone backends 64k; server backends.example.com service=_http._tcp resolve; } server { location / { proxy_pass http://backends; } }  在server指令中使用service参数指定需要解析SRV的名字和协议。这里我们使用**_http**和**_tcp**。除了使用service参数以及我们不需要指定端口号外，其他配置都和前一个例子一样。\n基于上一节通过nslookup命令返回的值， NGINX Plus会获取到3个后端服务：\n 10.0.0.10 – 主服务，端口：8090 权重：2 10.0.0.11 – 主服务，端口：8091 权重：1 10.0.0.12 – 倍服务，端口：8092 权重：1  如果我们配置了NGINX Plus活动监控，我们在面板中可以看到这些后端服务： 说明：请求会根据我们生命的权重进行分配。10.0.0.11:8091会接收到1/3的流量，10.0.0.10:8090会得到2/3。10.0.0.12:8092作为备服务在其他两个服务挂掉之前不会接收到任何流量。\n注意事项 当在NGINX Plus中使用DNS作为服务发现时，我们要时刻记住下面几件事：\n DNS服务需要高可用或者有备用服务。如果DNS服务关掉了，NGINX Plus会停止更新后端配置，并且会保留已经存在的后端服务，忽略TTL配置。 你可以在resolver中声明多个域名服务，如果一个挂了，NGINX Plus会使用另一个。 NGINX Plus除了使用DNS服务发现外，还提供了相关API，我们可以通过简单的HTTP请求来移除或添加upstream组中的后端服务。  其他例子 如果你还想研究完整的例子，可以参考下面几篇关于NGINX and NGINX Plus如何使用DNS作为服务发现的文章：\n Service Discovery for NGINX Plus Using DNS SRV Records from Consul Load Balancing Kubernetes Services with NGINX Plus  总结 NGINX Plus通过DNS提供了一种简单的方法来配置微服务环境中的负载均衡。R9版本开始支持SRV记录让NGINX Plus变得更加强大，因为它不但可以获取ip地址，还可以获取端口。\n原文链接：https://www.nginx.com/blog/dns-service-discovery-nginx-plus/\n","id":0,"section":"posts","summary":"\u003cp\u003e众所周知微服务架构的一个最大的有优势就是可以快速简单的扩容服务实例，要实现这个功能你需要一个负载均衡器来帮助你在众多的实例中选择一个可用的实例，并且能在可用实例发生变化的时候快速通知负载均衡器，这一系列的动作也被称作服务发现。\u003c/p\u003e\n\u003cp\u003eNGINX Plus提供了两种方式来和服务发现功能进行整合：\u003ccode\u003eNGINX Plus API\u003c/code\u003e 和 \u003ccode\u003eDomain Name System (DNS)\u003c/code\u003e ，本篇文章主要是介绍后一种。\u003c/p\u003e\n\u003cp\u003e当你通过增加（减少）虚拟机或者容器来扩容服务（本文称作\u003ccode\u003e后端服务\u003c/code\u003e）的时候，负载均衡器的配置也必须同步反映出\u003ccode\u003e后端服务\u003c/code\u003e每次变动。鉴于扩容随时都有可能发生，我们需要通过DNS来实现自动服务发现。\u003c/p\u003e\n\u003cp\u003e很多应用平台(例如Kubernets)都提供了基于DNS的服务发现功能，在文章末尾我们会提供一些链接来介绍如何将NGINX Plus整合进这些平台以及那些通过DNS来实现的服务发现的工具。\u003c/p\u003e","tags":["NGINX","DNS","服务发现"],"title":"[译]使用DNS为Nginx提供服务发现功能","uri":"https://xianliguang.github.io/2020/04/dns-service-discovery-nginx-plus/","year":"2020"}],"tags":[{"title":"DNS","uri":"https://xianliguang.github.io/tags/dns/"},{"title":"NGINX","uri":"https://xianliguang.github.io/tags/nginx/"},{"title":"服务发现","uri":"https://xianliguang.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"}]}